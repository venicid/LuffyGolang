package main

import (
	"log"
	"sync"
	"time"
)

// 读写锁
var rwMutex sync.RWMutex

func runReadLock(id int)  {
	log.Printf("[读任务 id：%d][进入读方法尝试获取锁]\n", id)
	rwMutex.RLock()
	log.Printf("[读任务 id：%d][get到读锁][开始干活，睡眠10秒]\n", id)
	time.Sleep(3*time.Second)
	rwMutex.RUnlock()
	log.Printf("[读任务 id：%d][完成任务，释放读锁]\n", id)
}

func runWriteLock(id int)  {
	log.Printf("[写任务 id：%d][进入写方法，尝试获取写锁]\n", id)
	rwMutex.Lock()
	log.Printf("[写任务 id：%d][get到写锁][开始干活，睡眠10秒]\n", id)
	time.Sleep(3*time.Second)
	rwMutex.Unlock()
	log.Printf("[写任务 id：%d][完成任务，释放写锁]\n", id)
}

// 全是写任务
func allWriteWorks(){
	for i:=1; i<3; i++{
	go runWriteLock(i)
}
}

// 全是读任务
func allReadWorks()  {
	for i:=1; i<3;i++{
		go runReadLock(i)
	}
}

// 先启动写任务
func writeFirst()  {
	go runWriteLock(1)
	time.Sleep(1 * time.Second)
	go runReadLock(1)
	go runReadLock(2)
	go runReadLock(3)

}

// 先启动读任务
func readFirst()  {
	go runReadLock(1)
	go runReadLock(2)
	go runReadLock(3)
	time.Sleep(1*time.Second)
	go runWriteLock(1)

}

func main(){

	log.Println("执行读写锁效果的函数")

	// 1. 同时多个写锁任务，说明如果并非使用读写锁的写锁时，退化成了互斥锁
	//allWriteWorks()

	// 2. 同时多个读锁任务，说明使用读写锁的读锁，可以同时施加多把读锁
	/*
		2021/08/06 06:37:30 执行读写锁效果的函数
		2021/08/06 06:37:30 [读任务 id：2][进入读方法尝试获取锁]
		2021/08/06 06:37:30 [读任务 id：2][get到读锁][开始干活，睡眠10秒]
		2021/08/06 06:37:30 [读任务 id：1][进入读方法尝试获取锁]
		2021/08/06 06:37:30 [读任务 id：1][get到读锁][开始干活，睡眠10秒]

		2021/08/06 06:37:33 [读任务 id：1][完成任务，释放读锁]
		2021/08/06 06:37:33 [读任务 id：2][完成任务，释放读锁]
	*/
	//allReadWorks()


	// 3. 先启动写锁任务，后并发5个读锁任务。当有写锁存在时，读锁时施加不了的。写锁释放完，读锁可以施加多个
	/*
	2021/08/06 06:39:33 执行读写锁效果的函数
	2021/08/06 06:39:33 [写任务 id：1][进入写方法，尝试获取写锁]
	2021/08/06 06:39:33 [写任务 id：1][get到写锁][开始干活，睡眠10秒]

	2021/08/06 06:39:34 [读任务 id：3][进入读方法尝试获取锁]
	2021/08/06 06:39:34 [读任务 id：1][进入读方法尝试获取锁]
	2021/08/06 06:39:34 [读任务 id：2][进入读方法尝试获取锁]

	2021/08/06 06:39:36 [读任务 id：3][get到读锁][开始干活，睡眠10秒]
	2021/08/06 06:39:36 [读任务 id：1][get到读锁][开始干活，睡眠10秒]
	2021/08/06 06:39:36 [读任务 id：2][get到读锁][开始干活，睡眠10秒]
	2021/08/06 06:39:36 [写任务 id：1][完成任务，释放写锁]
	2021/08/06 06:39:39 [读任务 id：3][完成任务，释放读锁]
	2021/08/06 06:39:39 [读任务 id：2][完成任务，释放读锁]
	2021/08/06 06:39:39 [读任务 id：1][完成任务，释放读锁]
	*/
	//writeFirst()


	// 4. 先并发5个读锁任务，后启动一个写锁任务，当有读锁时，阻塞写锁
	/*
	2021/08/06 06:41:14 执行读写锁效果的函数
	2021/08/06 06:41:14 [读任务 id：2][进入读方法尝试获取锁]
	2021/08/06 06:41:14 [读任务 id：2][get到读锁][开始干活，睡眠10秒]
	2021/08/06 06:41:14 [读任务 id：1][进入读方法尝试获取锁]
	2021/08/06 06:41:14 [读任务 id：1][get到读锁][开始干活，睡眠10秒]
	2021/08/06 06:41:14 [读任务 id：3][进入读方法尝试获取锁]
	2021/08/06 06:41:14 [读任务 id：3][get到读锁][开始干活，睡眠10秒]

	2021/08/06 06:41:15 [写任务 id：1][进入写方法，尝试获取写锁]

	2021/08/06 06:41:17 [读任务 id：1][完成任务，释放读锁]
	2021/08/06 06:41:17 [读任务 id：3][完成任务，释放读锁]
	2021/08/06 06:41:17 [读任务 id：2][完成任务，释放读锁]
	2021/08/06 06:41:17 [写任务 id：1][get到写锁][开始干活，睡眠10秒]

	2021/08/06 06:41:20 [写任务 id：1][完成任务，释放写锁]

	*/
	readFirst()

	time.Sleep(1 * time.Minute)
}